
___________________________________________________________________________________________________________________________
 _________________
|		  |
|      NOTE    Pn , Pm , ... short for register number n or m. for Exp) ASSN 1 100, mean put 100 into address which register 1 point to .
|_________________|


 _________________________________
|			     	  |
|   basic proggramming language   |_________________________________________________________________________________________
|_________________________________|



ASSN reg(number) Value // array[Pn] = Value , Value only is an decimal int , if you want to assign char , assign it's ascii code .

MOVE reg(number) ram_address // move a value from register to ram address .

ASSV reg(number1) reg(number2) // *reg(number1) = *reg(number2) , now can assign pointer to a variable as index then index++

COMP Px Py Pz // array[Px]> array[Py] ? array[Pz]=1 : array[Pz]=0 ; if you want to use < change parameters order .

EQAL Pn Pm Pz // array[Pz] = (array[Pn] == array[Pm]) , if there's value be same but indexes weren't in same domain , array[Pz] will 0 .

NEQL Pn Pm Pz // array[Pz] = (array[Pn] != array[Pm] ) , domain check like EQAL

CJUM Pn LINE// if(array[Pn]==1) goto to line LINE( line is int)

JUMP LINE // goto line LINE (LINE is a int)

HALT // finish program , if reached program RAM which commands wrote in it , become clear and control get back to simple os .

PUTC Pn // to print char or int print(array[Pn]) if in int domane print as int and if in char domain print as char .

PUTS Pn // to print a character of str . Pn refer to index thats a int in it . this int refer to index of str array.
      |___ when you need to loop to print a str : Pn is the address of index which in that index is address of the character of str you want to print ,
         |___ so to print you must putchar(array[index]) not array[Pn] . 
            |___ then for next character increase array[Pn] 1 more because Pn point to the value of index .
               |___ writer must know whats the start point of str and put it into another index to make index for printing .


PUTI Pn // printf("%d", array[Pn] )

ADDN Pn Pm Pz // array[Pz] = (array[Pn] + array[Pm])

ADDO Pn // array[Pn]++ --> exactly to printing a str char by char ;
      |__ first ASSN Pn 0 then after any print and befor any check for '\0' use it to increase Pn as 1


MULT Pn Pm Pz // array[Pz] = (array[Pn] x array[Pm])

GETC Pn  // get character and put in pn .

GETI Pn  // get int and put it to pn .

GETS Pn Pm // put str start from Pn and save how many chars got to Pm .

STCK Pn // Push array[Pn] to stack (not EIP registers stack)

PICK Pn // pop stack last index into array[Pn]

ANDC Pn Pm Pz// array[Pz] = (array[Pn] and array[Pm])

ORLC Pn Pm Pz// array[Pz] = (array[Pn] or array[Pm])

NOTC Pn // not array[Pn]



 ____________________________
|			     |
| API mother OS & program run : |___________________________________________________________________________________________________
|____________________________|


MKFL name.type // make file.type

MKDR name // make directory by name

SPCE // get me space for app running. make index of App's RAM zero .

OPNF name.type // open file.type

REDF name.type // read file.type and save it by protocol into App's RAM 

RUNF name.type // run file.type , from App's RAM index



___________________________________________________________________________________________

Exp) reg number :1 = index: 1 in registers list.
Exp) ASSN 1 100 -> reg[1] = 100 ; assign value 100 to register 1 .


EXP :

char a[]="ali" ;
for (int i =0 ; a[i]!= EOF ; i++){
putchar(a[i]) ; }
putchar('\n') ;

printf ("%s\n",a) ;


___________________________________________________________________________________________
