
Exp) Pn : 0x0001 = index: 1 which in ints range.
Exp) ASSN 0x0001 100 -> Ram[1] = 100 ;

array[Pn] type will represent by range of indexes . it works like subnet mask!

ASSN Pn Value // array[Pn] = Value , Value only is an decimal int , if you want to assign char , assign it's ascii code .

ASSV Pn Pm // array[Pn] = array[Pm] , now can assign pointer to a variable as index then index++ 

COMP Px Py Pz // array[Px]> array[Py] ? array[Pz]=1 : array[Pz]=0 ; if you want to use < change parameters order .

EQAL Pn Pm Pz // array[Pz] = (array[Pn] == array[Pm]) , if there's value be same but indexes weren't in same domain , array[Pz] will 0 .

NEQL Pn Pm Pz // array[Pz] = (array[Pn] != array[Pm] ) , domain check like EQAL

CJUM Pn LINE// if(array[Pn]==1) goto to line LINE( line is int)

JUMP LINE // goto line LINE (LINE is a int)

HALT // finish program , if reached program RAM which commands wrote in it , become clear and control get back to simple os .

PUTC Pn // to print char or int print(array[Pn]) if in int domane print as int and if in char domain print as char .

PUTS Pn // to print a character of str . Pn refer to index thats a int in it . this int refer to index of str array.
//    |___ when you need to loop to print a str : Pn is the address of index which in that index is address of the character of str you want to print ,
//       |___ so to print you must putchar(array[index]) not array[Pn] . 
//          |___ then for next character increase array[Pn] 1 more because Pn point to the value of index .
//             |___ writer must know whats the start point of str and put it into another index to make index for printing .

PUTI Pn // printf("%d", array[Pn] )

PRNT Pn Pm // print every characters between index n and m of array until characters is null . in str range .

ADDN Pn Pm Pz // array[Pz] = (array[Pn] + array[Pm])

ADDO Pn // array[Pn]++ --> exactly to printing a str char by char ;
//    |__ first ASSN Pn 0 then after any print and befor any check for '\0' use it to increase Pn as 1

MULT Pn Pm Pz // array[Pz] = (array[Pn] x array[Pm])

GETC Pn type// get input from stdin and save it to array[Pn] if it's int or char , and save it start from Pn in array if it's str .
//        |__ type only can be s for str / i for int / c for char ,  only and only by this syntax.(mean simple character)

STCK Pn // Push array[Pn] to stack

PICK Pn // pop stack last index into array[Pn]

ANDC Pn Pm Pz// array[Pz] = (array[Pn] and array[Pm])

ORLC Pn Pm Pz// array[Pz] = (array[Pn] or array[Pm])

NOTC Pn // not array[Pn]




to windows & program run :


MKFL name.type // make file.type

MKDR name // make directory by name

SPCE // get me space for app running. make index of App's RAM zero .

OPNF name.type // open file.type

REDF name.type // read file.type and save it by protocol into App's RAM 

RUNF name.type // run file.type , from App's RAM index

char a[]="ali" ;
for (int i =0 ; a[i]!= EOF ; i++){
putchar(a[i]) ; }
putchar('\n') ;

printf ("%s\n",a) ;